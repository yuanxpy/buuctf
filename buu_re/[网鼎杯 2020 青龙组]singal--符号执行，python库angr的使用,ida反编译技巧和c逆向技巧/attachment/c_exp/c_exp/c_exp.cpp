#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int vm_operad(int* a1, int a2)
{
    int result; // eax
    char Str[200]; // [esp+13h] [ebp-E5h] BYREF
    char v4; // [esp+DBh] [ebp-1Dh]
    int v5; // [esp+DCh] [ebp-1Ch]
    int v6; // [esp+E0h] [ebp-18h]
    int v7; // [esp+E4h] [ebp-14h]
    int v8; // [esp+E8h] [ebp-10h]
    int v9; // [esp+ECh] [ebp-Ch]
    char order[200] = { 0 };
    int s = 0;

    v9 = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    while (1)
    {
        result = v9;
        if (v9 >= a2)
            break;
        switch (a1[v9])
        {
        case 1:
            Str[v6 + 100] = v4;
            ++v9;
            ++v6;
            ++v8;
            break;
        case 2:
            v4 = a1[v9 + 1] + Str[v8];
            v9 += 2;
            break;
        case 3:
            v4 = Str[v8] - a1[v9];             //            v4 = Str[v8] - LOBYTE(a1[v9 + 1]);
            v9 += 2;
            break;
        case 4:
            v4 = a1[v9 + 1] ^ Str[v8];
            v9 += 2;
            break;
        case 5:
            v4 = a1[v9 + 1] * Str[v8];
            v9 += 2;
            break;
        case 6:
            ++v9;
            break;
        case 7:
            printf("%#x, ", a1[v9 + 1]);
            ++v7;
            v9 += 2;
            break;
        case 8:
            Str[v5] = v4;
            ++v9;
            ++v5;
            break;
        case 10:
            scanf("%s", Str);
            ++v9;
            break;
        case 11:
            v4 = Str[v8] - 1;
            ++v9;
            break;
        case 12:
            v4 = Str[v8] + 1;
            ++v9;
            break;
        }
        order[s++] = v9;
    }
    printf("\n长度是%d 顺序是: ",strlen(order));
    for (int i = 0; i < strlen(order); i++) {
        printf("%d, ", order[i]);
    }
    printf("\nv5是%d  v6是%d  v7是%d  v8是%d  v9是%d  \n", v5, v6, v7, v8, v9);
    return result;
}

void re_vm_operad1(int* a1, int a2)
{
    char str[100] = { 0 }; 
    int v4; 

    int v5; 
    int v6; 
    int v8; 
    int v9; 
    char order[200] = { 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 17, 18, 19, 20, 22, 23, 25, 26, 28, 29, 30, 31, 32, 33, 35, 36, 38, 39, 41, 42, 44, 45, 46, 47, 48, 49, 51, 52, 54, 55, 57, 58, 60, 61, 63, 64, 66, 67, 69, 70, 72, 73, 75, 76, 78, 79, 81, 82, 83, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114 };
    int key[20] = { 0x22, 0x3f, 0x34, 0x32, 0x72, 0x33, 0x18, 0xffffffa7, 0x31, 0xfffffff1, 0x28, 0xffffff84, 0xffffffc1, 0x1e, 0x7a };
    int s = 15;
    int positon = 0;
    v9 = 114;
    v8 = 15;
    v6 = 15;
    v5 = 15;
    while(1)
    {
        if (v9 < 0)
            break;
        positon = a1[v9];
        switch (a1[v9])
        {
        case 1:
            --v8;
            --v6;
            --v9;
            v4 = key[--s];
            break;
        case 2:
            v9 -= 2;
            str[v8] = v4 - a1[v9 + 1];
            break;
        case 3:
            v9 -= 2;
            str[v8] = v4 + char(a1[v9 + 1]);             //            v4 = str[v8] - lobyte(a1[v9 + 1]);
            break;
        case 4:
            v9 -= 2;
            str[v8] = a1[v9 + 1] ^ v4;
            break;
        case 5:
            v9 -= 2;
            str[v8] = v4 / a1[v9 + 1];
            break;
        case 6:
            --v9;
            break;
        case 7:
            v9 -= 2;
            break;
        case 8:
            --v5;
            --v9;
            v4 = str[v5];
            break;
        case 10:
            --v9;
            printf("%s", str);
            break;
        case 11:
            --v9;
            str[v8] = v4 + 1;
            break;
        case 12:
            --v9;
            str[v8] = v4 - 1;
            break;
        default:
            --v9;
        }

    }
    printf("%s", str);

}


void re_vm_operad2(int* a1, int a2)
{
    unsigned char flag[30] = { 0 }; // [esp+13h] [ebp-E5h] BYREF
     // 注意点1：这里应该是int而不是char，一开始因为直接从正向函数复制过来下意识地认为中间变量应该是char，其实不是，仔细看发现在正向比较的时候是和整型比较，这也是为什么key数组里
                //存在超过255的数字的原因，使用char复制key中的元素时会丢失精度所以会出现打印出部分flag的情况
    char order[100] = { 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 17, 18, 19, 20, 22, 23, 25, 26, 28, 29, 30, 31, 32, 33, 35, 36, 38, 39, 41, 42, 44, 45, 46, 47, 48, 49, 51, 52, 54, 55, 57, 58, 60, 61, 63, 64, 66, 67, 69, 70, 72, 73, 75, 76, 78, 79, 81, 82, 83, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114 };
    int key[20] = { 0x22, 0x3f, 0x34, 0x32, 0x72, 0x33, 0x18, 0xffffffa7, 0x31, 0xfffffff1, 0x28, 0xffffff84, 0xffffffc1, 0x1e, 0x7a };
    int i;
    int position;
    int m = 15;        //
    int n = 15;       //v8
    int j = 15;
    int temp;
    for (int k = strlen(order) - 1; k >= 0; k--)
    {

        i = order[k];
        position = a1[i];
        switch (a1[i])
        {
        case 1:
            --m;
            --n;
            temp = key[m];                         //注意点3：在看wp的时候非常不解，为什么这里这个原函数中的Str要换成key，而其他位置的Str要换成flag，后来经过对比发现
                                                    //了关键，我使用ida进行反编译的时候反编译出了Str[+100]这种东西，而在wp中的图里同位置就是Str[+0]，一开始我以为ida编译错了
                                                    //就直接忽视了这个100，却没仔细想过上面正向函数同样用Str[+100]得到了正确的结果，其实我的ida将wp中的两个大小为100数组合成了一个
                                                    //大小为200的数组，然后用Str[+100]表示第二个数组，这里是一个ida反编译需要注意的点
            break;
        case 2:
            flag[n] = temp - a1[i + 1];
            break;
        case 3:
            flag[n] = temp + char(a1[i+1]);             //            v4 = Str[v8] - LOBYTE(a1[v9 + 1]); 注意点2：原函数里用了lOBYTE一开始我根据经验认为即a1[v9+1]，但其实不是
                                                         //             这样的，因为原数字是整形，取byte，即4字节取1字节而非LOWORD四字节去二字节，所以要用char（+1）而非（+0）
            break;
        case 4:
            flag[n] = (a1[i + 1] ^ temp) & 0xff;
            break;
        case 5:
            flag[n] = temp / a1[i + 1];
            break;
        case 6:
            break;
        case 8:
            temp = flag[--j];                            //注意点4：这点是经过我上面的第一个逆向函数到的的结论，那就是order数组是有必要的，一开始看wp我其实不明白为什么要求order数组
                                                            //后来经过第一个逆向函数的调试，我发现两个函数区别从在order=84的时候开始，1函数会经过case7而直接到82，2函数会根据数组到83
                                                            //原因是路径不唯一，即可以是83-->+1-->84和82-->+2-->84这样一来同样的结果逆向后会出现不同的初始路径，所以要求出来order
            break;
        case 11:
            flag[n] = temp + 1;
            break;
        case 12:
            flag[n] = temp - 1;
            break;
        }
    }
    printf("%s", flag);
}



int main()
{
    unsigned char ida_chars[] =
    {
      0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00,
      0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00,
      0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00,
      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
      0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00,
      0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
      0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00,
      0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF,
      0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
      0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF,
      0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF,
      0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00,
      0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00
    };
    int* a = (int*)ida_chars;
    //vm_operad(a, 114);
    re_vm_operad2(a, 114);
}
