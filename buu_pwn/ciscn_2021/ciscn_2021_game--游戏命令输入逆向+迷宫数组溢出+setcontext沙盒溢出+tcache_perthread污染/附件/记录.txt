本题的难点倒不在于setcontext，而是在逆向过程和别让init和create的层层套娃chunk把你给绕晕了，我就是一开始根本看都看不懂逆向过程，而后又被chunk套娃绕晕了，所以只能被wp牵着鼻子走，好在有前面一道题的setcontext再加上动调理解了师傅的exp，下面简单记录下：

逆向过程就不介绍了，泄露libc就是直接申请0x410大小的chunk，free后进入unsorted bin，再申请回来利用残留的bk指针泄露libc，泄露heap base则是利用tcache残留的fd指针，

因为第三位是要置零的，所以写入一个字节的b'a'没有影响；最后则是核心漏洞点——game数组溢出，game进行过程中up，down，right，left是没有边界检测的，而实际上这个可以被溢出的chunk是init申请的迷宫chunk，而其下方紧邻着的就是第一个人物chunk的内容，这里我们通过down三次就把为6的id写入了第一个人物chunk的size，成功扩大了chunk，经过释放再申请即可达到溢出第二个人物chunk的目的，即可以先释放第二个人物chunk，再通过第一个人物chunk修改已释放的第二个人物chunk的fd指针，达到double free的攻击条件

再下面就是setcontext，在前面的题里面已经理解得比较透彻了，这里不再赘述，仅仅提一下本题并没有另设chunk来设置orw和栈，而是直接利用tcache控制块直接写入orw和栈，很方便。

最后提一下有一个我没理解的点，那就是【放入的位置也就是行和列是由随机数生成的，当然这里看似随机，实际上一旦init中初始的col和row确定，那么每次程序运行，每个角色最初的位置是固定的；】，从事实角度看，这是正确的，但我没有理解为什么这里是固定的