ASLR

通过运行程序可以发现无论是64位的程序还是32位的程序，每一次执行，程序装载到内存后，其代码段和数据段的地址始终是相同的，可见ASLR并不会随机化代码段和数据段。但是对于存放在函数调用栈中的局部变量localVar，每一次执行其地址都不同，可见ASLR随机化了栈的地址。更细心可以发现，即使四次执行栈的地址被随机化了，但是其低4位始终是同一个值8，可见栈的随机化是对低4位对齐的。同样可以通过ldd命令查看程序加载动态库的地址，会发现其同样被随机化了，但是对低12位对齐（所谓页面的4K对齐？？）。
事实上，Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作，而不是 ASLR。要开启 PIE，在使用 gcc 进行编译链接时添加 -fpie -pie 选项即可（gcc是默认打开PIE保护的）。但是只有在开启 ASLR 之后，PIE 才会生效。


本题使用的特殊栈帧

main函数开辟栈帧并没有用常见的PUSH EBP; MOV EBP ESP;  SUB ESP OFFSET的方式来开辟栈帧，这样的话返回地址就并没有存放在ebp的上面。由于有ASLR的栈基址随机化保护，那么每次栈的基址不同，那and esp, 0FFFFFFF0h是不是会导致每次程序执行有不同的偏移呢？并不是，因为在上面的ASLR保护机制处我们已经分析发现了，虽然ASLR会使得栈的基址随机化，但是其低四位仍然是固定的，那么尽管main函数采用上述的开辟栈帧的方式，程序每次加载，main函数栈帧的ebp指针到返回地址的偏移仍然是固定的，且等于esp的低四位表示的字节数+4字节+4字节。这样就可以在gdb中动态调试，查看esp的低四位，在main函数的入口处打断点，此时esp指向的是返回地址，且其低四位为0xC：
